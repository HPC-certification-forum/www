#! /usr/bin/env python3

import argparse
import catalogueParser
import hashlib
import json
import os
import pseudoRandom
import sys
import testUtils
import time

def parseArgs():
	"""Define the options of the testGenerator, parse the command line, and return the options object."""
	optionsParser = argparse.ArgumentParser()
	optionsParser.add_argument('-r', '--random-seed', type=int, default=0, help="The random seed to use to generate the test")

	subparsers = optionsParser.add_subparsers(dest='subcommand')

	generateParser = subparsers.add_parser('generate', help="generate a test from a given catalogue, provides JSON object of the test on stdout")
	generateParser.add_argument('-i', '--input', required=True, help="path to a question catalogue file")
	generateParser.add_argument('-t', '--timeout', type=int, default=900, help="time allowed for completing and submitting the test in seconds")
	generateParser.add_argument('-q', '--questions', type=int, default=10, help="number of questions to include in an individualized test")
	generateParser.add_argument('-a', '--answers', type=int, default=3, help="number of answers that are included per 'select multiple' question")
	generateParser.add_argument('-s', '--server-secret', default="server-secret",
		help="file containing random data that is secret to the server running the test generation and grading.")
	generateParser.add_argument('-c', '--create', dest='create', action='store_true', help="create a server secret file if none exists")
	generateParser.add_argument('-n', '--no-create', dest='create', action='store_false',
		help="error out if the server secret file does not exist, this is the default")
	generateParser.set_defaults(create=False)

	checkParser = subparsers.add_parser('check', help="grade a test that's provided as a JSON object on stdin")
	checkParser.add_argument('-s', '--server-secret', default="server-secret",
		help="file containing random data that is secret to the server running the test generation and grading.")
	checkParser.add_argument('-v', '--verify', default = True, action='store_false', help="Disable certain verifications")
	checkParser.add_argument('-p', '--print-corrected-test', default = False, action='store_true', help="Print the corrected test")
	checkParser.add_argument('-f', '--file', default = None, help="Read the given file")

	return optionsParser.parse_args()

def readServerSecret(path: str, canCreate: bool, wantCreate: bool) -> bytes:
	"""Read the server secret.

	If the server secret file is not found, this function allows it to be created transparently if both canCreate and wantCreate are true.
	If canCreate is True and wantCreate is False, failure to read will be an error, but a hint will be displayed to supply the --create option.
	If canCreate is False, failure to read is just a hard error."""

	try:
		with open(path, 'rb') as file:
			return file.read()
	except:
		if canCreate and wantCreate:
			try:
				with open(path, 'xb') as file:
					secret = os.urandom(32)
					file.write(secret)
					return secret
			except:
				sys.exit("error creating server secret file")
		elif canCreate:
			sys.exit("error: no server secret file found\npass --create to create one with random content")
		else:
			sys.exit("error: no server secret file found")

def hashMetadata(secret: bytes, nonce: bytes, timeout: str, catalogue: str, questionCount: int, answerCount: int) -> str:
	hasher = hashlib.sha256()
	hashInput = secret.hex() + " " + nonce.hex() + " " + timeout + " " + catalogue + " " + str(questionCount) + " " + str(answerCount)
	hasher.update(hashInput.encode("utf-8"))
	return hasher.digest().hex()

def subcommand_generate(options):
	"""Implementation of the 'generate' subcommand."""

	secret = readServerSecret(options.server_secret, True, options.create)

	catalogue = catalogueParser.parseFile(options.input)
	rng = pseudoRandom.PseudoRandom(seedInt = options.random_seed)
	nonce = rng.getSeed()
	timeout = str(time.time() + options.timeout)
	questions = testUtils.selectQuestions(rng, catalogue, options.questions, options.answers, False)

	test = {
		'nonce': nonce.hex(),
		'catalogue': options.input,	#FIXME: use only the hash of the catalogue, not the whole path
		'timeout': timeout,
		'question count': options.questions,
		'answer count': options.answers,
		'checksum': hashMetadata(secret, nonce, timeout, options.input, options.questions, options.answers),	#FIXME: use only the hash of the catalogue, not the whole path
		'questions': questions
	}
	json.dump(test, sys.stdout, indent = 4)

def checkInput(conditionCallback, errorMessage: str = "error: input is not a valid test result") -> None:
	"""Execute the conditionCallback, and call sys.exit(errorMessage) if either the result is False, or an exception is raised."""

	try:
		if not conditionCallback():
			sys.exit(errorMessage)
	except:
		sys.exit(errorMessage)

def subcommand_check(options):

	#XXX: Python's json module sees data that we cannot control.
	#     Any vulnerability in this module will be a vulnerability of us.
	if options.file:
		file = open(options.file, "r")
	else:
		file = sys.stdin

	test = json.load(file)
	checkInput(lambda: test["nonce"])
	checkInput(lambda: test["catalogue"])
	checkInput(lambda: test["timeout"])
	checkInput(lambda: test["question count"])
	checkInput(lambda: test["answer count"])
	checkInput(lambda: test["checksum"])
	checkInput(lambda: test["questions"])

	#XXX: Do not read the secret before reading the JSON, so that bugs in Python's json module that leak information cannot leak the secret.
	#     Of course, this is just to raise the bar for successful pwning, a remote code execution vulnerability will give our secret away.
	secret = readServerSecret(options.server_secret, False, False)
	checkInput(lambda: test["checksum"] == hashMetadata(secret, bytes.fromhex(test["nonce"]), test["timeout"], test["catalogue"], test["question count"], test["answer count"]))

	#Security assertion:
	#Now we know that the triple of
	#  * nonce
	#  * timeout
	#  * catalogue
	#has been generated by us, so their values are legit.
	#So, now we can start *interpreting* those values.
	if options.verify:
		checkInput(lambda: float(test["timeout"]) > time.time())
	catalogue = catalogueParser.parseFile(test["catalogue"])
	nonce = bytes.fromhex(test["nonce"])
	rng = pseudoRandom.PseudoRandom(nonce, options.random_seed)
	if options.random_seed != 0:
		# verify that nonce is the right seed
		if nonce != rng.seed:
			print("error: input is invalid for this user")
			sys.exit(1)
	referenceTest = testUtils.selectQuestions(rng, catalogue, test["question count"], test["answer count"], True)

	grade = testUtils.gradeTest(referenceTest, test["questions"])
	checkInput(lambda: grade != None)	#throw an error if the submitted test did not match the reference

	if options.print_corrected_test:
		test["grade"] = grade
		print(json.dumps(test))
	else:
		print(grade)

options = parseArgs()
if options.subcommand == "generate":
	subcommand_generate(options)
elif options.subcommand == "check":
	subcommand_check(options)
else:
	sys.exit("internal error: code is inconsistent with argument parser definition\nplease report this bug")
